# Phalcon Clean Architecture Scaffold #

Данный репозиторий содержит базовый "скелет" проекта, архитектура которого сделана 
согласно требованиям Clean Architecture с использованием фреймворка Phalcon.

## Зависимости

#### Зависимости веб-сервера:

- [PHP](https://secure.php.net/) >= 7.0
- [PDO](https://secure.php.net/manual/en/book.pdo.php), [MySQL driver](https://secure.php.net/manual/en/ref.pdo-mysql.php)
- [php-yaml](https://secure.php.net/manual/en/book.yaml.php)
- [php-mbstring](https://secure.php.net/manual/en/book.mbstring.php)
- [php-json](https://secure.php.net/manual/en/book.json.php)
- [php-mcrypt](https://secure.php.net/manual/en/book.mcrypt.php)
- [Composer](https://getcomposer.org/)
- [Phalcon Framework](https://phalconphp.com/en/) >= 3.2
- [Redis](https://redis.io/), [php-redis](https://github.com/phpredis/phpredis)
- [Memcached](http://memcached.org/), [php-memcached](https://secure.php.net/manual/en/book.memcached.php)
- [libgearman](http://gearman.org/), [php-gearman](https://secure.php.net/manual/en/book.gearman.php)
- [symfony/validator](https://github.com/symfony/validator)

#### Зависимости пакетов Composer

- [woxapp/phalcon-restful](https://bitbucket.org/WoxappGIT/libs_phalcon_restful/)
- [firebase/php-jwt](https://github.com/firebase/php-jwt)
- [swiftmailer/swiftmailer](https://github.com/swiftmailer/swiftmailer)
- [guzzlehttp/guzzle](https://github.com/guzzle/guzzle)

#### Рекомендуемые инструменты

- [Phalcon Developer Tools](https://github.com/phalcon/phalcon-devtools)

## Проект

#### Установка

- Клонировать скелет с помощью команды:
```
git clone https://bitbucket.org/WoxappGIT/base_arch_php_phalcon/
```
- Перейти в директорию проекта:
```
cd ./base_arch_php_phalcon
```
- Установить необходимые зависимости с помощью Composer:
```
composer install
```
*Эта команда также проверит веб-сервер на наличие всех необходимых зависимостей.*

- Прописать необходимые подключения к БД и оперативным хранилищам в `app/Configuration/config.yml`

- С помощью поиска в коде проекта найти все подобные комментарии:

```
/* FIXME: Developers should change this according to the project. */
```
И изменить определенные строки кода, к которым были оставленны эти комментарии

- Изменить пространство имен с `Woxapp\Scaffold` на `Woxapp\[PROJECT]` - где `[PROJECT]` - название разрабатываемого проекта.

#### Структура проекта

Весь исходный код проекта должен хранится в директории `app`, и распределен по соответствующим
директориям слоев, к которым относится необходимый класс. Согласно принципам Clean Architecture,
проект разделяется на три слоя, которые независимы друг от друга, и взаимодействуют между собой 
через интерфейс. В данной структуре, эти слои отображены тремя директориями - `Presentation`, `Domain`, `Data`.
Ниже будет описано подробное назначение данных директорий. 

#### Dependency Injection

[DI](https://en.wikipedia.org/wiki/Dependency_injection) в данном проекте используется по стандартной механике паттерна Dependency Injection на языке PHP. Все зависимости
помещаются в DI контейнер используя анонимные функции, это позволяет сократить время инициализации приложения и всегда
загружать только те зависимости, которые требуются во время обработки конкретного запроса от клиента. В данном скелете,
DI контейнер находится в файле `app/Bootstrap.php`, в этом файле разработчик должен объявлять все новые сервисы, которые
будут реализованы в проекте. DI контейнер, объявленный в этом файле в будущем будет доступен по всему приложению.

#### Пространства имен

Все классы, которые добавляются к этому скелету должны находится в пространстве имен: `\Woxapp\[PROJECT_NAME]\[LAYER_NAME]`,
где `PROJECT_NAME` - имя проекта, `LAYER_NAME` - имя слоя соответственно. Пространства имен
всегда должны быть заданы согласно стандарту [PSR-4](http://www.php-fig.org/psr/psr-4/), и прописаны как в `composer.json` для автозагрузчика Composer,
так и в `app/Bootstrap.php` для автозагрузчика Phalcon. Стандартное пространтсво имен, которое прописано в данном репозитории
необходимо полностью заменить на вышеописанное, для того чтобы избежать путаницы в названиях.

#### Конфигурация

Конфигурация в проекте использует формат [YAML](http://yaml.org/), файл конфигурации загружается общий для проекта, происходит это
в `app/Bootstrap.php`, стандартно загружается файл `app/Configuration/config.yml`, который содержит все необходимые
настройки скелета и подключения к БД.

#### Обработка ошибок

Все ошибки преобразовываются в исключения, а их обработка происходит в классе Application.

#### Cross-Origin Resource Sharing

Данный скелет поддерживает автоматические ответы для корректного функционирования запросов, которые сообщают
клиенту о том что определенные ресурсы в API доступны через CORS. Настройка CORS происходит следующим образом:

- При определении роута в `Routes.php`, необходимо обозначить, что добавляемый путь также будет доступен с помощью OPTIONS.

- Все параметры и действия данный скелет совершает автоматически, включая получение разрешенных типов запроса, Origin хоста и значение параметра Credentials.

*Заметка: Разрешенные типы запроса получаются автоматически из объекта Router, Origin хост получается из текущего файла 
конфигурации (секция application.links, параметр origin)

#### Автоматический деплоймент

Данный скелет предусматривает любой способ автоматического деплоймента, который должен быть настроен и сконфигурирован
на усмотрение разработчика. Главным фактором тут является конфигурация проекта, которая находится в `app/Configuration/config.yml`,
и может быть распределена по нескольким "стейджам" проекта. Необходимой зависимостью является автоматическая ротация конфигураций,
которая должна быть выполнена при необходимости разделения проекта на "стейджи" на усмотрения разработчика.

#### Роутинг

Роутинг в данном скелете реализован согласно паттерну [Front Controller](https://en.wikipedia.org/wiki/Front_controller), новые роуты прописываются в файле `app/Routes.php`,
В проекте используется кастомный класс Router, который расширяет встроенные в Phalcon [Router](https://docs.phalconphp.com/en/3.2/routing). Для добавления нового маршрута
должен использоваться метод `addRoute` в который дополнительно передается класс, реализующий интерфейс `Woxapp\Scaffold\Domain\Interfaces\InteractorInterface`, который должен быть вызван
при совпадении pattern'а этого маршрута с URI, а также правила валидации, формат которых описан ниже.

#### Точка входа, диспетчер запросов от клиента

Точкой входа является файл `public/index.php`, согласно требованиям данного скелета - `index.php` всегда должен
быть единственным файлом в публичной директории. Этот файл в первую очередь подключает `app/Bootstrap.php`, который
выполняет роль "инициализатора" всего проекта и описан выше. Затем, создается экземпляр класса `app/Application`, и управление
передается этому классу.

#### Application и диспетчер запросов

Данный скелет не использует встроенную в Phalcon реализацию Application по причине того, что Phalcon это MVC фреймворк,
и встроенный в фреймворк Application в конце каждого цикла работы диспетчера вызывает компонент View, для того чтобы рендерить
результат пользователю. Так как этот скелет предназначен в первую очередь для разработки REST API, компонент View нам не требуется,
мы обходимся одной функцией [json_encode](http://php.net/manual/en/function.json-encode.php). У данной реализации Application есть одна публичная функция - dispatch(), которая
принимает управление обработки запроса от клиента на себя, используя встроенный в фреймворк компонент - Dispatcher. Этот компонент
использует другой кастомный класс Router, для того чтобы распарсить URL, который запросил клиент, и в случае
если такой URL прописан в `app/Routes.php` - вызвать метод `process`, у класса реализующего интерфейс `Woxapp\Scaffold\Domain\Interfaces\InteractorInterface`,
который в свою очередь передается в качестве аргумента конструктора в класс Route, который расширяет встроенный в Phalcon класс Route.

#### Presentation Layer

Presentation слой является самым верхним слоем, который должен быть реализован по принципам Clean Architecture. Задача данного
слоя в этом скелете - обработка входящего запроса, валидация заголовков и тела запроса, и последующая передача нормализированных
данных в Domain Layer. Обработка, валидация и нормализация данных происходит в классе RequestHandler, который принимает в конструкторе объект запроса. 
Передача в Domain Layer происходит в классе Application с помощью интерфейса `app/Domain/Interfaces/InteractorInterface`.

#### Domain Layer

Domain слой по принципам Clean Architecture является следующим слоем после Presentation, и содержит в себе определения бизнес-логики
приложения. Бизнес-логика распределена по логическим блокам, которые называются Use Case, и хранятся в директории `app/Domain/Usecase`.
В случае данного скелета - каждый Use Case должен быть унаследован от `Woxapp\Scaffold\Domain\UseCase\Interactor`, который в свою очередь 
реализует интерфейс `Woxapp\Scaffold\Domain\Interfaces\InteractorInterface`, содержащий `process` и `output` порты (это функции, через 
которые Presentation и Domain слои взаимодействуют между собой). Под каждый маршрут должен быть создан свой класс Use Case.

#### Data Layer

Data слой по принципам Clean Architecture является "последним" слоем, и являет собой реализацию паттерна проектирования - Repository,
Назначение Data слоя в этом скелете - работа со всеми подключенными к проекту хранилищами данных, включая реляционные БД (MySQL),
оперативные хранилища (Redis, Memcached), и другие используемые проектом хранилища. В отличии от Domain слоя, данный слой не содержит
конкретного интерфейса, и используется в Domain слое напрямую в Use Case. Работы с БД должна быть реализована через Phalcon ORM,
для генерации сущностей рекомендуется использовать [phalcon-devtools](https://github.com/phalcon/phalcon-devtools), все сущности хранятся в директории `app/Data/Entity`, и имеют
соответствующее пространство имен.

### Валидация

Сервис валидации является частью Presentation слоя и предназначен для использования только в нем.
Он состоит из нескольких зависимых друг от друга частей:

- Validator - Сервис, который используется в `RequestHandler` для валидации заголовков и тела запроса.
Из `Application` он вызывается с помоцью метода `validateRequest`. В него нужно передать массив правил валидации,
который описан следующим пунктом.

- *Rules - Правила валидации заголовков и тела запроса, которые находятся в директории Rules. 
Под каждый маршрут создаются отдельные классы валидации. 
В этих классах создаются статические методы, которые должны возвращать массив, состоящий из обязательных заголовков (`required_headers`), обязательных параметров (`required_params`) и правил валидации (`rules`).
Пример можно посмотреть в классе `Woxapp\Scaffold\Presentation\Service\Validation\Rules\ExampleRules`

#### Validator

Сервис валидации является оберткой над Symfony Validation Component и имеет следующие функции:

`validateHeaders` и `validateBody` - Валидируют переданную таргетированную сущность (массив, который передается 1-ым параметром в метод), используя правила валидации,
которые были переданы 3-им необязательным параметром, валидацию проходят только те поля в таргетированной сущности, которые были
переданы 2-ым параметром (обязательные параметры) или те, которые будут найдены среди ключей правил валидации (необязательные параметры).
**Все остальные параметры будут считатся валидатором неизвестными**.

Отличия между методами `validateHeaders` и `validateBody` в том, что при проверке обязательных и необязательных параметров в методе `validateHeaders` дополнительно используется список из `HttpHeaders::PREDEFINED_REQUEST_HEADERS`

**ВНИМАНИЕ**: У одного ключа может быть несколько правил валидации (их количество ничем не ограничивается), в случае нескольких правил валидации -
они передаются во вложенном массиве.
Названия ключей в `rules` определяют к какому типу параметров они будут применены: headers или body.
Названия правил для headers всегда начинаются с большой буквы и из специальных символов могут содержать только `-` (дефис) 
Названия правил для body всегда начинаются с маленькой буквы и помимо `-` могут содержать `_`
